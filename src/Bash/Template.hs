{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ExtendedDefaultRules #-}

module Bash.Template
  ( script
  ) where

import           Text.InterpolatedString.Perl6  ( q
                                                , qc
                                                )
import           RIO                            ( Text
                                                , Bool(..)
                                                )
import           RIO.Text                       ( unlines )
import           App                            ( ScriptOptions(..) )

header :: Text
header = [q|#!/usr/bin/env bash
# generated by curl-gen (https://github.com/PKopel/curl-gen)
|]

print_usage :: ScriptOptions -> Text
print_usage opts = [qc|
function print_usage() \{
    echo -e "Usage: $(basename $0) <command> [<options>]
Options:
    -h | --help
            print this message
{if threads opts then thrd else ""}
    --dry-run
            display curl command instead of running it

    -f | --file <file path>
            use contents of <file path> as call data
{if random opts then rand else ""}
    --set <paths=values>
            replace fields in data object with provided values, e.g.
            --set '.test="asdfgh"' sets field test of data object
            to value "asdfgh"
"
}
|]
  where
    thrd = [q|
    -t | --threads <number>
            run <number> concurrent threads.
|] :: Text
    rand = [q|
    --rand <paths=types>
            replace fields in data object with random values.
            Supported types are I for integers and S for strings.
|] :: Text

read_values :: Text
read_values = [q|
# usage: read_values <path> <value>;
function read_values() {
    local FIELD_PATH=$(echo $1 | sed 's/\[/\(/g' - | sed 's/\]/\)/g' - )
    VALUES["$FIELD_PATH"]="$2"
}
|]

generate_values :: Text
generate_values = [q|
# usage: generate_values <path> <type>;
function generate_values() {
    local FIELD_PATH=$(echo $1 | sed 's/\[/\(/g' - | sed 's/\]/\)/g' - )
    local TYPE=$2
    local GENERATOR
    if [[ $TYPE == S ]]; then
        GENERATOR='echo \"$(cat /dev/random | tr -dc "[:alnum:]" | head -c 20)\"'
    elif [[ $TYPE == I ]]; then
        GENERATOR='od -vAn -N2 -tu2 < /dev/random'
    else
        echo "wrong type: $TYPE for $FIELD_PATH"
    fi
    VALUES["$FIELD_PATH"]="$GENERATOR"
}
|]

values :: Bool -> Text
values rand = [qc|
declare -A VALUES
{read_values}
{if rand then generate_values else ""}
|] 
    

functions :: [Text] -> Text
functions fs = [qc|
################### auto-generated functions start ###################

{unlines fs}

#################### auto-generated functions end ####################
|]

main :: ScriptOptions -> Text
main opts = [qc|
CURL=$(which curl)

COMMAND=()
ADDRESS="example.com"
THREADS=1
declare -A PATH_PARAMS

while [[ "$#" -gt 0 ]]; do
    OPTION="$1"
    shift
    case $OPTION in
    --dry-run)
        CURL="echo curl"
        ;;
    --help | -h)
        print_usage
        exit 0
        ;;
    --addr | -a)
        ADDRESS="$1"
        shift
        ;;
{if threads opts then thrd else ""}
    --file | -f)
    	FILE_PATH="$1"
    	shift
    	;;
{if random opts then rand else ""}
    --set)
        while [[ "$1" && ! "$1" == -* ]]; do
            FIELD="$(echo $1 | cut -d= -f1)"
            VALUE="$(echo $1 | cut -d= -f2)"
            read_values "$FIELD" "$VALUE"
            shift
        done
        ;;
    --*)
        PATH_PARAMS["$OPTION"]="$1"
        shift
        ;;
    *)
        COMMAND+=("$OPTION")
    esac
done

FUNCTION=$( echo "$\{COMMAND[*]}" | sed 's| |_|g' - )

if [ "$(type -t "$FUNCTION")" == "function" ]; then
    {if threads opts then loop else "$FUNCTION"}
else
    echo "wrong command: $FUNCTION"
    print_usage
    exit 1
fi
|]
  where
    thrd = [q|    --threads | -t)
        THREADS="$1"
        shift
        ;;|] :: Text
    rand = [q|    --rand)
        while [[ "$1" && ! "$1" == -* ]]; do
            FIELD="$(echo $1 | cut -d= -f1)"
            TYPE="$(echo $1 | cut -d= -f2)"
            generate_values "$FIELD" "$TYPE"
            shift
        done
        ;;|] :: Text
    loop = [q|for T in $(seq 1 $THREADS); do
        $FUNCTION &
    done|] :: Text

script :: ScriptOptions -> [Text] -> Text
script opts fs = unlines 
  [ header
  , print_usage opts
  , values (random opts)
  , functions fs
  , main opts
  ]

