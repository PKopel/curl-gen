{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ExtendedDefaultRules #-}

module Powershell.Template
  ( script
  ) where

import           Text.InterpolatedString.Perl6  ( q
                                                , qc
                                                )
import           RIO                            ( Text
                                                , Bool(..)
                                                )
import           RIO.Text                       ( unlines )
import           App                            ( ScriptOptions(..) )

header :: Text
header = [q|#!/usr/bin/env pwsh
# generated by curl-gen (https://github.com/PKopel/curl-gen)
|]

param :: ScriptOptions -> Text
param opts = [qc|param (
    [Parameter(
        Position = 0,    
        ValueFromRemainingArguments = $true
    )]
    [string[]]$command,

    [switch]$dryRun,

    [string]$addr,
    { if threads opts then thrd else ""}
    [string]$file,

    [string[]]$set,
    { if random opts then rand else ""}
    [string[]]$path
)
|]
  where
    rand = [q|
    [string[]]$rand,
|] :: Text
    thrd = [q|
    [int]$threads = 1,
|] :: Text

set_values :: Bool -> Text
set_values rand = [qc|
function Set-Values \{
    param (
        [string[]]$set,
    { if rand then paramRand else "" }
        [string[]]$path
    )

    $values = @\{}

    foreach ($x in $set + $path) \{
        $field, $value = $x -split "="
        $values[$field] = "$value"
    }
    { if rand then foreachRand else ""}
    return [hashtable]$values
}
|]
  where 
    paramRand = [q|
        [string[]]$rand,
|] :: Text
    foreachRand = [q|
    foreach ($x in $rand) {
        $field, $type = $x -split "="
        $value = "wrong type"
        Switch ($type) {
            "S" { $value = "-join ((65..90) + (97..122) | Get-Random -Count 5 | % {[char]$_})" }
            "I" { $value = "Get-Random" }
        }
        $values[$field] = $value
    }
|] :: Text


set_object :: Text
set_object = [q|
function Set-Object {
    param (
        [Parameter(Mandatory)]
        [hashtable]$values,
    
        [Parameter(Mandatory, ValueFromPipeline)]
        [hashtable]$object
    )

    function Set-Field {
        param (
            [string[]]$fs,
            [string]$val,
            [hashtable]$obj
        )

        if ($fs.count -gt 1) {
            $f, $fs = $fs
            $obj[$f] = Set-Field -fs $fs -val $val -obj $obj[$f]
        }
        else {
            $f = $fs[0]
            if ($f.Contains('[')) {
                # turn 'array[int]' into array and int
                $a, [int]$i, $_ = $f -split { $_ -in "[", "]" }
                $obj[$a][$i] = Invoke-Expression $val
            }
            else {
                $obj[$f] = Invoke-Expression $val
            }
        }
        return $obj
    }

    foreach ($key in $values.keys) {
        # drop leading .
        $_, $fields = $key -split { $_ -eq "." }
        if ($fields.count -gt 0) {
            $object = Set-Field -fs $fields -val $values[$key] -obj $object
        }
    }

    return $object
}
|]

functions :: [Text] -> Text
functions fs = [qc|
################### auto-generated functions start ###################

{unlines fs}

#################### auto-generated functions end ####################
|]

main :: Text
main = [q|
if ($MyInvocation.InvocationName -ne '.') {
    $cmd = $command -join "-"
    Invoke-Expression "$cmd @PsBoundParameters"
}
|]

script :: ScriptOptions -> [Text] -> Text
script opts fs = unlines 
  [ header
  , param opts
  , set_values (random opts)
  , set_object
  , functions fs
  , main
  ]

