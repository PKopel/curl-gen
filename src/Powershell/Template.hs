{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExtendedDefaultRules #-}

module Powershell.Template
  ( script
  ) where

import           RIO                            ( (<>)
                                                , Text
                                                , Bool(..)
                                                )
import           RIO.Text                       ( unlines )
import           Types.Script                   ( ScriptOptions(..) )

header :: Text
header = "#!/usr/bin/env pwsh\n\
\# generated by curl-gen (https://github.com/PKopel/curl-gen)\n\
\ "

param :: ScriptOptions -> Text
param opts = "param (\n\
\    [Parameter(\n\
\        Position = 0,\n\
\        ValueFromRemainingArguments = $true\n\
\    )]\n\
\    [string[]]$command,\n\
\    \n\
\    [switch]$dryRun,\n\
\    \n\
\    [string]$addr,\n\
\    " <> (if threads opts then thrd else "") <> "\n\
\    [string]$file,\n\
\    \n\
\    [string[]]$set,\n\
\    " <> (if random opts then rand else "") <> "\n\
\    [string[]]$path\n\
\)"
  where
    rand = "\n\
\    [string[]]$rand,\n\
\ " :: Text
    thrd ="\n\
\    [int]$threads = 1,\n\
\ " :: Text

set_values :: Bool -> Text
set_values rand = "\n\
\function Set-Values {\n\
\    param (\n\
\        [string[]]$set,\n\
\    " <> (if rand then paramRand else "") <> "\n\
\        [string[]]$path\n\
\    )\n\
\    \n\
\    $values = @{}\n\
\    \n\
\    foreach ($x in $set + $path) {\n\
\        $field, $value = $x -split \"=\"\n\
\        $values[$field] = \"$value\"\n\
\    }\n\
\    " <> (if rand then foreachRand else "") <> "\n\
\    return [hashtable]$values\n\
\}"
  where 
    paramRand = "\n\
\        [string[]]$rand,\n\
\ " :: Text
    foreachRand = "\n\
\    foreach ($x in $rand) {\n\
\        $field, $type = $x -split \"=\"\n\
\        $value = \"wrong type\"\n\
\        Switch ($type) {\n\
\            \"S\" { $value = \"-join ((65..90) + (97..122) | Get-Random -Count 5 | % {[char]$_})\" }\n\
\            \"I\" { $value = \"Get-Random\" }\n\
\        }\n\
\        $values[$field] = $value\n\
\    }" :: Text


set_object :: Text
set_object = "\n\
\function Set-Object {\n\
\    param (\n\
\        [Parameter(Mandatory)]\n\
\        [hashtable]$values,\n\
\    \n\
\        [Parameter(Mandatory, ValueFromPipeline)]\n\
\        [hashtable]$object\n\
\    )\n\
\    \n\
\    function Set-Field {\n\
\        param (\n\
\            [string[]]$fs,\n\
\            [string]$val,\n\
\            [hashtable]$obj\n\
\        )\n\
\    \n\
\        if ($fs.count -gt 1) {\n\
\            $f, $fs = $fs\n\
\            $obj[$f] = Set-Field -fs $fs -val $val -obj $obj[$f]\n\
\        }\n\
\        else {\n\
\            $f = $fs[0]\n\
\            if ($f.Contains('[')) {\n\
\                # turn 'array[int]' into array and int\n\
\                $a, [int]$i, $_ = $f -split { $_ -in \"[\", \"]\" }\n\
\                $obj[$a][$i] = Invoke-Expression $val\n\
\            }\n\
\            else {\n\
\                $obj[$f] = Invoke-Expression $val\n\
\            }\n\
\        }\n\
\        return $obj\n\
\    }\n\
\    \n\
\    foreach ($key in $values.keys) {\n\
\        # drop leading .\n\
\        $_, $fields = $key -split { $_ -eq \".\" }\n\
\        if ($fields.count -gt 0) {\n\
\            $object = Set-Field -fs $fields -val $values[$key] -obj $object\n\
\        }\n\
\    }\n\
\    \n\
\    return $object\n\
\}"

functions :: [Text] -> Text
functions fs = "\n\
\################### auto-generated functions start ###################\n\
\    \n\
\ " <> unlines fs <> "\n\
\    \n\
\#################### auto-generated functions end ####################\n\
\ "

main :: Text
main = "\n\
\if ($MyInvocation.InvocationName -ne '.') {\n\
\    $cmd = $command -join \"-\"\n\
\    Invoke-Expression \"$cmd @PsBoundParameters\"\n\
\}"

script :: ScriptOptions -> [Text] -> Text
script opts fs = unlines 
  [ header
  , param opts
  , set_values (random opts)
  , set_object
  , functions fs
  , main
  ]

